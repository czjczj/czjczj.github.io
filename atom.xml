<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>一棵大白菜</title>
  
  
  <link href="https://zjcheng.site/atom.xml" rel="self"/>
  
  <link href="https://zjcheng.site/"/>
  <updated>2021-03-23T07:58:44.627Z</updated>
  <id>https://zjcheng.site/</id>
  
  <author>
    <name>zj_cheng</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java 基础 - 面向对象</title>
    <link href="https://zjcheng.site/2021/03/23/java%E5%9F%BA%E7%A1%80-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <id>https://zjcheng.site/2021/03/23/java%E5%9F%BA%E7%A1%80-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</id>
    <published>2021-03-23T07:57:46.000Z</published>
    <updated>2021-03-23T07:58:44.627Z</updated>
    
    <content type="html"><![CDATA[<h3 id="重载与重写的区别"><a href="# 重载与重写的区别" class="headerlink" title="重载与重写的区别"></a>重载与重写的区别</h3><hr><table><thead><tr><th>类型</th><th>重载</th><th>重写</th></tr></thead><tbody><tr><td>方法名</td><td>一定不能修改</td><td>一定不能修改</td></tr><tr><td>参数列表</td><td>必须修改</td><td>一定不能修改</td></tr><tr><td>返回类型</td><td>可以修改</td><td>可以不同，但必须是父类返回值的派生类</td></tr><tr><td>访问权限</td><td>可以修改</td><td>一定不能做更加严格的显示(可以降低限制)</td></tr><tr><td>抛出异常</td><td>可以修改</td><td>可以减少或者删除，不能抛出新的或者更广的异常</td></tr></tbody></table><span id="more"></span><h3 id="抽象类和接口的区别"><a href="# 抽象类和接口的区别" class="headerlink" title="抽象类和接口的区别"></a>抽象类和接口的区别</h3><hr><table><thead><tr><th></th><th>abstract class</th><th>interface</th></tr></thead><tbody><tr><td>继承</td><td>只能 extends 一个类</td><td>可以 implements 多个接口</td></tr><tr><td>字段</td><td>可以定义实例字段</td><td>不能定义</td></tr><tr><td>抽象方法</td><td>可以定义抽象方法</td><td>均为抽象方法</td></tr><tr><td>非抽象方法</td><td>可以包含抽象方法</td><td>不能包含</td></tr></tbody></table><ul><li>抽象类中可以包含抽象方法和成员变量，但是接口只能含有抽象方法</li><li>它们都是本质上定义接口规范。保证所有子类都有相同的接口规范</li><li>一个实体类只能继承一个抽象类，但是可以实现多个接口</li><li>接口之间的继承使用 extends 关键词</li><li>接口在定义变量时，默认修饰 <code>public static final</code>，可以省去不写</li><li>接口在定义方法是，默认修饰 <code>public abstract</code>, 可以省去。</li></ul><h3 id="访问作用域 -private-protected-public"><a href="# 访问作用域 -private-protected-public" class="headerlink" title="访问作用域 (private, protected, public)"></a> 访问作用域(private, protected, public)</h3><hr><table><thead><tr><th></th><th>本类</th><th>同一个包(子类和无关类)</th><th>不同包下(子类)</th><th>不同包下(无关类)</th></tr></thead><tbody><tr><td>private</td><td>Y</td><td>N</td><td>N</td><td>N</td></tr><tr><td>default</td><td>Y</td><td>Y</td><td>N</td><td>N</td></tr><tr><td>protected</td><td>Y</td><td>Y</td><td>Y</td><td>N</td></tr><tr><td>public</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr></tbody></table><ul><li>final<ul><li>定义为 final 的类，不能被继承</li><li>定义为 final 的方法，不能被子类重写</li><li>定义为 final 的成员变量，可阻止其被重写赋值</li><li>定义为 final 的局部变量，可阻止其被重写赋值</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;重载与重写的区别&quot;&gt;&lt;a href=&quot;#重载与重写的区别&quot; class=&quot;headerlink&quot; title=&quot;重载与重写的区别&quot;&gt;&lt;/a&gt;重载与重写的区别&lt;/h3&gt;&lt;hr&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;重载&lt;/th&gt;
&lt;th&gt;重写&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;方法名&lt;/td&gt;
&lt;td&gt;一定不能修改&lt;/td&gt;
&lt;td&gt;一定不能修改&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;参数列表&lt;/td&gt;
&lt;td&gt;必须修改&lt;/td&gt;
&lt;td&gt;一定不能修改&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;返回类型&lt;/td&gt;
&lt;td&gt;可以修改&lt;/td&gt;
&lt;td&gt;可以不同，但必须是父类返回值的派生类&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;访问权限&lt;/td&gt;
&lt;td&gt;可以修改&lt;/td&gt;
&lt;td&gt;一定不能做更加严格的显示(可以降低限制)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;抛出异常&lt;/td&gt;
&lt;td&gt;可以修改&lt;/td&gt;
&lt;td&gt;可以减少或者删除，不能抛出新的或者更广的异常&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;</summary>
    
    
    
    <category term="编程语言" scheme="https://zjcheng.site/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="Java" scheme="https://zjcheng.site/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java 基础 - 集合</title>
    <link href="https://zjcheng.site/2021/03/23/java%E5%9F%BA%E7%A1%80-%E9%9B%86%E5%90%88/"/>
    <id>https://zjcheng.site/2021/03/23/java%E5%9F%BA%E7%A1%80-%E9%9B%86%E5%90%88/</id>
    <published>2021-03-23T07:35:47.000Z</published>
    <updated>2021-03-23T07:51:41.488Z</updated>
    
    <content type="html"><![CDATA[<h3 id="List- 有序列表的集合"><a href="#List- 有序列表的集合" class="headerlink" title="List (有序列表的集合)"></a>List (有序列表的集合)</h3><hr><ul><li>子类 ArrayList, LinkedList</li><li>方法  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">(1) 添加一个元素： boolean add(val)</span><br><span class="line">(2) 指点索引添加元素： boolean add(idx, val)</span><br><span class="line">(3) 删除某个元素： int remove(val)</span><br><span class="line">(4) 删除指定索引元素：int remove(idx)</span><br><span class="line">(5) 得到列表元素大小：int size()</span><br><span class="line">(6) 得到指定索引元素：int get(idx)</span><br><span class="line">(7) 数组转 list: Integer[] arr &#x3D; &#123;1,2,3&#125;</span><br><span class="line">              List&lt;Integer&gt; list &#x3D; List.of(array)</span><br><span class="line">(8) list 转数组：Object[] arr &#x3D; list.toArray()</span><br><span class="line">              Integer[] arr &#x3D; list.toArray(new Integer[n])</span><br><span class="line">(9) 静态初始化：List&lt;String&gt; list &#x3D; List.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)</span><br><span class="line">(10) 判断是否存在某个元素，通过 equals 判断：list.contains(val)  boolean</span><br><span class="line">(11) 返回某个元素的索引： list.indexOf(val) 如果某有返回 -1</span><br><span class="line">(12) 涉及到自定义类 equals 重写：</span><br><span class="line">        public boolean euqals(Object o)&#123;</span><br><span class="line">            if(o isinstanceof E)&#123;</span><br><span class="line">                 Person p &#x3D; (Person) o; &#x2F;&#x2F;Person 为自定义类，包含 name(引用字段), age(非引用字段)</span><br><span class="line">                &#x2F;&#x2F; 非引用字段调用 &#x3D;&#x3D; 判断</span><br><span class="line">                &#x2F;&#x2F; 引用字段调用 Objects.equals() 判断, 省去 null 值的判断</span><br><span class="line">                return Objects.equals(this.name, p.name) &amp;&amp; this.age&#x3D;&#x3D;p.age;</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><span id="more"></span></li><li>优缺点：<table><thead><tr><th>属性</th><th>ArrayList</th><th>LinkedList</th></tr></thead><tbody><tr><td>得到指定索引元素</td><td>快</td><td>O(n) 需要重头查找</td></tr><tr><td>尾部插入元素</td><td>快</td><td>快</td></tr><tr><td>指定索引插入 / 删除元素</td><td>O(n) 需要移动元素</td><td>不需要移动元素</td></tr><tr><td>内存占用</td><td>少</td><td>大</td></tr></tbody></table></li><li>Iterator 遍历 List 最为高效；实现了 Iterable 的集合类可使用 for each 遍历；</li></ul><h3 id="Set- 没有重复元素的集合"><a href="#Set- 没有重复元素的集合" class="headerlink" title="Set (没有重复元素的集合)"></a>Set (没有重复元素的集合)</h3><hr><ul><li>子类：HashSet(无序), TreeSet(它实现了 SortedSet 接口, 有序)</li><li>方法：  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(1) 添加元素： boolean add(e)</span><br><span class="line">(2) 删除元素： boolean remove(e)</span><br><span class="line">(3) 是否包含某个元素：boolean contains(e)</span><br></pre></td></tr></table></figure></li><li>应用场景：在聊天软件中，发送方发送消息时，遇到网络超时后就会自动重发，因此，接收方可能会收到重复的消息，在显示给用户看的时候，需要首先去重。请练习使用 Set 去除重复的消息</li></ul><h3 id="Map- 通过 key-value 查找的映射表集合 - 不保证顺序"><a href="#Map- 通过 key-value 查找的映射表集合 - 不保证顺序" class="headerlink" title="Map (通过 key-value 查找的映射表集合, 不保证顺序)"></a>Map (通过 key-value 查找的映射表集合, 不保证顺序)</h3><hr><ul><li>子类: HashMap, HashTable, TreeMap(通过实现 Comparator 接口可以保证按照 key 排序), ConcurrentHashMap</li><li>方法：  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">(1) 放入元素：put(key, val) </span><br><span class="line">(2) 重复放入某个 key，覆盖 val 值，返回老的 val 值，如果第一次放入则返回 null</span><br><span class="line">(3) 得到元素：get(key) 如果没有则返回 null</span><br><span class="line">(4) 判断是否含有某个 key: containsKey(key)</span><br><span class="line">(5) 获取 key 的集合： map.keySet()</span><br><span class="line">(6) for-each 遍历：</span><br><span class="line">        1) for(String key: map.keySet())&#123;</span><br><span class="line">              String val &#x3D; map.get(s);</span><br><span class="line">              &#x2F;&#x2F;out(key, val)</span><br><span class="line">           &#125;</span><br><span class="line">        2) for(Map.Entry&lt;String, String&gt; entry: map.entrySet())&#123;</span><br><span class="line">              String key &#x3D; entry.getKey();</span><br><span class="line">              String val &#x3D; entry.getValue();</span><br><span class="line">              &#x2F;&#x2F;out(key, val);</span><br><span class="line">           &#125;</span><br><span class="line">(7) 自定义类中 hashCode() 方法重写：</span><br><span class="line">    int hashCode()&#123;</span><br><span class="line">        return Objects.hashCode(firstName, lastName, age) &#x2F;&#x2F; 参数为成员变量</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li>特点：<ul><li>常用于频繁查询内容，作为缓存 cache, 提高查询效率。</li><li>其内部 key 的比较采用的是 equals 方法</li><li>其内部 key 对应的索引计算方法 hashCode()，返回值为 int。</li><li>为了保证 Map 能够正常运行需要正确覆盖 equals() 和 hashCode() 方法。</li><li>Map 首先通过计算 key 的 hashCode()得到内部索引位置，如果不同 key 的 hashCoder()相同(哈希冲突)，再次遍历 list, 因为其内部其实存储的为 List&lt;Entry&lt;String, Person&gt;&gt; 列表，不单单是一个 Person.</li></ul></li></ul><h3 id="自定义类变为可比较类型的三种方法 - 这里以 Person 自定义类举例 - 按照 age 从小到大排序"><a href="# 自定义类变为可比较类型的三种方法 - 这里以 Person 自定义类举例 - 按照 age 从小到大排序" class="headerlink" title="自定义类变为可比较类型的三种方法 (这里以 Person 自定义类举例, 按照 age 从小到大排序)"></a> 自定义类变为可比较类型的三种方法(这里以 Person 自定义类举例, 按照 age 从小到大排序)</h3><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">(1) 自定义类实现 Comparable 接口</span><br><span class="line">class Person implements Comparable&#123;</span><br><span class="line">    String name;</span><br><span class="line">    int age;</span><br><span class="line">    public Perosn(int age, String name)&#123;</span><br><span class="line">        this.age &#x3D; age;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public int compareTo(Object o)&#123;</span><br><span class="line">        if(o instanceof Person)&#123;</span><br><span class="line">            Person p &#x3D; (Person)o;</span><br><span class="line">            if(this.age&#x3D;&#x3D;p.age) return 0;</span><br><span class="line">            return this.age&lt;p.age? -1: 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">TreeSet&lt;Person&gt; set &#x3D; new TreeSet&lt;&gt;();</span><br><span class="line">set.add(new Person(20, &quot;Bob&quot;));</span><br><span class="line">set.add(new Person(21, &quot;Aim&quot;));</span><br><span class="line">set.add(new Person(22, &quot;John&quot;));</span><br><span class="line"></span><br><span class="line">(2) 匿名函数 Comparator</span><br><span class="line">TreeSet&lt;Person&gt; set &#x3D; new TreeSet&lt;&gt;(new Comparator&lt;Person&gt;(</span><br><span class="line">    @Override</span><br><span class="line">    public int compare(Person a, Person b)&#123;</span><br><span class="line">        if(a.age&#x3D;&#x3D;b.age) return 0;</span><br><span class="line">        return a.age&lt;b.age? -1: 1;</span><br><span class="line">    &#125;</span><br><span class="line">));</span><br><span class="line"></span><br><span class="line">(3) 实现自定义类 Comparator</span><br><span class="line">class MyComparator implements Comparator&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int compare(Object a, Object b)&#123;</span><br><span class="line">        Person a &#x3D; (Person)a;</span><br><span class="line">        Person b &#x3D; (Person)b;</span><br><span class="line">        if(a.age&#x3D;&#x3D;b.age) return 0;</span><br><span class="line">        return a.age&lt;b.age? -1: 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Queue- 队列，-FIFO"><a href="#Queue- 队列，-FIFO" class="headerlink" title="Queue (队列， FIFO)"></a>Queue (队列， FIFO)</h3><hr><ul><li>常用实现类：  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;String&gt; que &#x3D; new LinkedList&lt;&gt;()</span><br><span class="line">Queue&lt;String&gt; que &#x3D; new PriorityQueue&lt;&gt;() &#x2F;&#x2F; 优先队列， 其内部元素不许实现 Comparable 接口</span><br></pre></td></tr></table></figure></li><li>方法：  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(1) 获取队列长度：size()</span><br><span class="line">(2) 队尾添加元素：add() &#x2F; offer()  boolean</span><br><span class="line">(3) 队头删除元素：remove() &#x2F; poll() 返回元素类型</span><br><span class="line">(4) 获取队头元素但不删除： element() &#x2F; peek()</span><br></pre></td></tr></table></figure></li></ul><h3 id="Deque- 双端队列，两端插入"><a href="#Deque- 双端队列，两端插入" class="headerlink" title="Deque (双端队列，两端插入)"></a>Deque (双端队列，两端插入)</h3><hr><ul><li>常用实现类：  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;String&gt; que &#x3D; new LinkedList&lt;&gt;()</span><br></pre></td></tr></table></figure></li><li>方法 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(1) 队头 &#x2F; 队尾 添加元素：addFirst(), offerFirst() &#x2F; addLast(), offerFirst()</span><br><span class="line">(2) 队头 &#x2F; 队尾 删除元素：removeFirst(), pollFirst() &#x2F; removeLast(), pollLast()</span><br><span class="line">(3) 队头 &#x2F; 队尾 取出元素：getFirst(), peekFirst() &#x2F; getLast(), peekLast()</span><br></pre></td></tr></table></figure></li></ul><h3 id="Stack- 栈，-FILO"><a href="#Stack- 栈，-FILO" class="headerlink" title="Stack (栈， FILO)"></a>Stack (栈， FILO)</h3><hr><ul><li>方法  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;Integer&gt; stk &#x3D; new Stack&lt;&gt;();</span><br><span class="line">(1) 栈顶添加元素: stk.push()</span><br><span class="line">(2) 取出栈顶元素(不删除)： stk.peek()</span><br><span class="line">(3) 取出栈顶元素(并删除)： stk.poll()</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;List-有序列表的集合&quot;&gt;&lt;a href=&quot;#List-有序列表的集合&quot; class=&quot;headerlink&quot; title=&quot;List (有序列表的集合)&quot;&gt;&lt;/a&gt;List (有序列表的集合)&lt;/h3&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;子类 ArrayList, LinkedList&lt;/li&gt;
&lt;li&gt;方法  &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(1) 添加一个元素： boolean add(val)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(2) 指点索引添加元素： boolean add(idx, val)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(3) 删除某个元素： int remove(val)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(4) 删除指定索引元素：int remove(idx)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(5) 得到列表元素大小：int size()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(6) 得到指定索引元素：int get(idx)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(7) 数组转list: Integer[] arr &amp;#x3D; &amp;#123;1,2,3&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              List&amp;lt;Integer&amp;gt; list &amp;#x3D; List.of(array)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(8) list转数组：Object[] arr &amp;#x3D; list.toArray()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              Integer[] arr &amp;#x3D; list.toArray(new Integer[n])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(9) 静态初始化：List&amp;lt;String&amp;gt; list &amp;#x3D; List.of(&amp;quot;A&amp;quot;, &amp;quot;B&amp;quot;, &amp;quot;C&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(10) 判断是否存在某个元素，通过 equals判断：list.contains(val)  boolean&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(11) 返回某个元素的索引： list.indexOf(val) 如果某有返回 -1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(12) 涉及到自定义类equals重写：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        public boolean euqals(Object o)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            if(o isinstanceof E)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                 Person p &amp;#x3D; (Person) o; &amp;#x2F;&amp;#x2F;Person为自定义类，包含name(引用字段), age(非引用字段)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#x2F;&amp;#x2F;非引用字段调用 &amp;#x3D;&amp;#x3D; 判断&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#x2F;&amp;#x2F;引用字段调用 Objects.equals() 判断, 省去null值的判断&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                return Objects.equals(this.name, p.name) &amp;amp;&amp;amp; this.age&amp;#x3D;&amp;#x3D;p.age;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            return false;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="编程语言" scheme="https://zjcheng.site/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="Java" scheme="https://zjcheng.site/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>热爱生命</title>
    <link href="https://zjcheng.site/2021/03/11/%E7%83%AD%E7%88%B1%E7%94%9F%E5%91%BD/"/>
    <id>https://zjcheng.site/2021/03/11/%E7%83%AD%E7%88%B1%E7%94%9F%E5%91%BD/</id>
    <published>2021-03-11T12:15:42.000Z</published>
    <updated>2021-03-11T13:00:37.286Z</updated>
    
    <content type="html"><![CDATA[<center><h1> 热爱生命 </h1><p>我不去想，<br>是否能够成功 ，<br>既然选择了远方 ，<br>便只顾风雨兼程。<br></p><span id="more"></span><p>我不去想，<br>能否赢得爱情 ，<br>既然钟情于玫瑰 ，<br>就勇敢地吐露真诚 。<br></p><p>我不去想，<br>身后会不会袭来寒风冷雨 ，<br>既然目标是地平线，<br>留给世界的只能是背影 。<br></p><p>我不去想，<br>未来是平坦还是泥泞 ，<br>只要热爱生命 </font>，<br>一切，都在意料之中。</p></center>]]></content>
    
    
    <summary type="html">&lt;center&gt;
&lt;h1&gt;热爱生命&lt;/h1&gt;
&lt;p&gt;
我不去想，&lt;br&gt;
是否能够成功 ，&lt;br&gt;
既然选择了远方 ，&lt;br&gt;
便只顾风雨兼程。&lt;br&gt;
&lt;/p&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://zjcheng.site/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="诗歌" scheme="https://zjcheng.site/tags/%E8%AF%97%E6%AD%8C/"/>
    
  </entry>
  
</feed>
