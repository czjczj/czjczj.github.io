<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>一棵大白菜</title>
  
  
  <link href="https://zjcheng.site/atom.xml" rel="self"/>
  
  <link href="https://zjcheng.site/"/>
  <updated>2021-03-28T07:46:49.067Z</updated>
  <id>https://zjcheng.site/</id>
  
  <author>
    <name>zj_cheng</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>百面机器学习</title>
    <link href="https://zjcheng.site/2021/03/28/%E7%99%BE%E9%9D%A2%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    <id>https://zjcheng.site/2021/03/28/%E7%99%BE%E9%9D%A2%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-03-28T06:58:06.000Z</published>
    <updated>2021-03-28T07:46:49.067Z</updated>
    
    <content type="html"><![CDATA[<h4 id="为什么需要对于数值类型特征进行特征归一化"><a href="# 为什么需要对于数值类型特征进行特征归一化" class="headerlink" title="为什么需要对于数值类型特征进行特征归一化?"></a>为什么需要对于数值类型特征进行特征归一化?</h4><p>为了消除不同数据特征之间的量纲影响，我们需要对于特征进行归一化处理，是的不同指标之间具有可比性。其主要方法为以下两种:</p><ul><li>线性函数归一化 (Min-Max Scaling)：对原始特征进行线性变换，归一化到[0,1] 范围内。<script type="math/tex; mode=display">X_{norm} = \frac{X - X_{min}}{X_{max} - X_{min}}</script></li><li>零均值归一化：会将原始特征映射到均值为 0，方差为 1 的分布上。设原始特征的均值和方差分别为 $\mu, \delta$，归一化公式。<script type="math/tex; mode=display">z = \frac{x - \mu}{\delta}</script><span id="more"></span>Python 代码实现<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 线性函数归一化, 零均值归一化</span><br><span class="line">from sklearn.preprocessing import MinMaxScaler, StandardScaler</span><br><span class="line">scaler &#x3D; MinMaxScaler()</span><br><span class="line">x &#x3D; scaler.fit(x)</span><br><span class="line">x &#x3D; scaler.transform(x)</span><br></pre></td></tr></table></figure>好处：归一化后能够加快模型的梯度下降收敛速度（线性回归，逻辑回归，SVM, NN），树模型不适用。<br><img src="/imgs/bmjqxx/1-1.png" style="width:90%;height:80%;display:inline-block;text-align:center"></li></ul>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;为什么需要对于数值类型特征进行特征归一化&quot;&gt;&lt;a href=&quot;#为什么需要对于数值类型特征进行特征归一化&quot; class=&quot;headerlink&quot; title=&quot;为什么需要对于数值类型特征进行特征归一化?&quot;&gt;&lt;/a&gt;为什么需要对于数值类型特征进行特征归一化?&lt;/h4&gt;&lt;p&gt;为了消除不同数据特征之间的量纲影响，我们需要对于特征进行归一化处理，是的不同指标之间具有可比性。其主要方法为以下两种:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;线性函数归一化(Min-Max Scaling)：对原始特征进行线性变换，归一化到[0,1]范围内。&lt;script type=&quot;math/tex; mode=display&quot;&gt;X_{norm} = \frac{X - X_{min}}{X_{max} - X_{min}}&lt;/script&gt;&lt;/li&gt;
&lt;li&gt;零均值归一化：会将原始特征映射到均值为0，方差为1 的分布上。设原始特征的均值和方差分别为$\mu, \delta$，归一化公式。&lt;script type=&quot;math/tex; mode=display&quot;&gt;z = \frac{x - \mu}{\delta}&lt;/script&gt;</summary>
    
    
    
    <category term="面试" scheme="https://zjcheng.site/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试 机器学习" scheme="https://zjcheng.site/tags/%E9%9D%A2%E8%AF%95-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>CRF</title>
    <link href="https://zjcheng.site/2021/03/25/CRF/"/>
    <id>https://zjcheng.site/2021/03/25/CRF/</id>
    <published>2021-03-25T06:55:35.000Z</published>
    <updated>2021-03-25T07:27:17.903Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1- 马尔科夫随机场"><a href="#1- 马尔科夫随机场" class="headerlink" title="1. 马尔科夫随机场"></a>1. 马尔科夫随机场</h4><ul><li><p>场: 在空间的某个区域内, 如果除了个别点以外, 其他的该区域内的每个点 p 都有一个确定的量 $f(p)$, 那么 <strong> 该区域 </strong> 称为 $f(p)$ 的场。</p></li><li><p>随机过程: 设 $T$ 是一无限实数集, 把依赖于 $t \in T$ 的一族 (无限多个) 随机变量称为随机过程。即为</p><script type="math/tex; mode=display">{X(t), t \in T}</script></li><li><p>随机场: 如果 $T$ 是 $n$ 维度空间的一个子集, 即 $t$ 是一个 $n$ 维向量, 此时随机过程称为随机场。</p></li></ul><h4 id="2- 条件随机场 CRF-conditional-random-field"><a href="#2- 条件随机场 CRF-conditional-random-field" class="headerlink" title="2. 条件随机场 CRF (conditional random field)"></a>2. 条件随机场 CRF (conditional random field)</h4><p>定义: 设 $X=(x_1, x_2, …, x_n)$ 和 $Y=(y_1, y_2, …, y_n)$ 均为线性表示的随机变量序列。若在 <strong> 给定 </strong> 随机变量序列<strong>x 的条件下</strong>。 随机变量序列 $Y$ 的条件概率分布 $P(Y|X)$ 构成条件随机场, 并满足马尔科夫性:</p><script type="math/tex; mode=display">P(Y_i|X, Y1,...,Y_{i-1},Y_{i+1},...,Y_n) = P(Y_i|X,Y_{i-1},Y_{i+1})</script><p>此时称 $P(Y|X)$ 为线性条件随机场。<br><span id="more"></span></p><h4 id="3- 线性链条件随机场公式"><a href="#3- 线性链条件随机场公式" class="headerlink" title="3. 线性链条件随机场公式"></a>3. 线性链条件随机场公式</h4><p><img src="https://pic1.zhimg.com/80/v2-ee91ebeecd409eb4a33af209fb8b0f18_720w.jpg" style="width:80%;height:80%;display:inline-block;text-align:center"></p><p>特征函数定义:</p><p><img src="https://pic1.zhimg.com/80/v2-799f58be49406ee7478ed52d94a3f188_720w.jpg" style="width:80%;height:80%;display:inline-block;text-align:center"></p><p>为了简单起见，将转移特征和状态特征及其权值用统一符号表示。条件随机场简化公式如下:</p><p><img src="https://pic4.zhimg.com/80/v2-e0f24d7d3c60c3fb0cfba7f10e3f33b3_720w.jpg" style="width:80%;height:80%;display:inline-block;text-align:center"></p><h4 id="4- 举例说明"><a href="#4- 举例说明" class="headerlink" title="4. 举例说明"></a>4. 举例说明</h4><p><img src="https://pic3.zhimg.com/80/v2-98c85098271f347be65745d6d5b4e8de_720w.jpg" style="width:80%;height:80%;display:inline-block;text-align:center"></p><p><img src="https://pic2.zhimg.com/80/v2-980fd0c5d7c701e69aa3435f51901cb9_720w.jpg" style="width:80%;height:80%;display:inline-block;text-align:center"></p><p>则标注序列为 {B、I、I} 的联合概率分布如下：<br><img src="https://pic4.zhimg.com/80/v2-15120e3c0ae1e8c49defca66ac945143_720w.jpg" style="width:80%;height:80%;display:inline-block;text-align:center"></p><h4 id="5- 朴素贝叶斯 -HMM- 逻辑回归 -CRF 对比表格"><a href="#5- 朴素贝叶斯 -HMM- 逻辑回归 -CRF 对比表格" class="headerlink" title="5. 朴素贝叶斯, HMM, 逻辑回归, CRF 对比表格"></a>5. 朴素贝叶斯, HMM, 逻辑回归, CRF 对比表格</h4><p><img src="https://pic4.zhimg.com/v2-104861c06cb27665b8d4287d7ab55f9b_r.jpg" style="width:80%;height:80%;display:inline-block;text-align:center"></p><div class="table-container"><table><thead><tr><th></th><th>原理</th><th>特点</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>朴素贝叶斯</td><td>贝叶斯公式</td><td>条件概率</td><td>条件推理</td><td>训练复杂</td></tr><tr><td>HMM</td><td>马尔科夫性</td><td>依赖前一个状态</td><td>训练快</td><td>局部最优</td></tr><tr><td>逻辑回归</td><td>逻辑函数</td><td>取值[0,1]</td><td>模拟概率</td><td>准确率不高</td></tr><tr><td>CRF</td><td>Hammersley-Clifford 定理</td><td>最大团乘积</td><td>特征灵活, 全局最优</td><td>设置特征模板</td></tr></tbody></table></div><h4 id="6-CRF 的发展简史"><a href="#6-CRF 的发展简史" class="headerlink" title="6. CRF 的发展简史"></a>6. CRF 的发展简史</h4><p>CRF 一直时标注问题的基本模型。</p><div class="table-container"><table><thead><tr><th>历史</th><th>模型</th></tr></thead><tbody><tr><td>机器学习阶段</td><td>CRF</td></tr><tr><td>深度学阶段</td><td>BiLSTM-CRF, BILSTM-CNN-CRF</td></tr><tr><td>Attention 阶段</td><td>Transformer-CRF, BERT-BiLSTM-CRF</td></tr></tbody></table></div><h4 id="7-CRF 的应用"><a href="#7-CRF 的应用" class="headerlink" title="7. CRF 的应用"></a>7. CRF 的应用 </h4><h5 id="7-1- 中文分词"><a href="#7-1- 中文分词" class="headerlink" title="7.1. 中文分词"></a>7.1. 中文分词</h5><p> 基于 CRF 由字构词方法的基本思想，基本原理如下：</p><p><img src="https://pic2.zhimg.com/80/v2-31b9b12996bef5bfc857eabcc276e899_720w.jpg" style="width:80%;height:80%;display:inline-block;text-align:center"></p><p>CRF 中文分词的图结构如下：</p><p><img src="https://pic2.zhimg.com/80/v2-8c7825e6a2a700faf96c7ed2aa1c7ed9_720w.jpg" style="width:80%;height:80%;display:inline-block;text-align:center"></p><h5 id="7-2- 命名实体识别"><a href="#7-2- 命名实体识别" class="headerlink" title="7.2. 命名实体识别"></a>7.2. 命名实体识别 </h5><p> 基于 CRF 的命名实体识别过程如下：</p><p><img src="https://pic1.zhimg.com/80/v2-e6b99a5894e1d65a0b8802ed718b861c_720w.jpg" style="width:80%;height:80%;display:inline-block;text-align:center"></p><p>CRF 命名实体识别的图结构如下：</p><p><img src="https://pic2.zhimg.com/80/v2-cdacd9ff36747052097e5516360a0155_720w.jpg" style="width:80%;height:80%;display:inline-block;text-align:center"></p><h5 id="7-3- 词性标注"><a href="#7-3- 词性标注" class="headerlink" title="7.3. 词性标注"></a>7.3. 词性标注 </h5><p> 基于 CRF 词性标注方法的基本思想，基本原理如下：</p><p><img src="https://pic3.zhimg.com/80/v2-d6156399374fb6f9f813301559cb3f32_720w.jpg" style="width:80%;height:80%;display:inline-block;text-align:center"></p><p>CRF 中文词性标注的图结构如下：</p><p><img src="https://pic2.zhimg.com/80/v2-9d7163ea8fbb8484d1521936fe2ef139_720w.jpg" style="width:80%;height:80%;display:inline-block;text-align:center"></p>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;1-马尔科夫随机场&quot;&gt;&lt;a href=&quot;#1-马尔科夫随机场&quot; class=&quot;headerlink&quot; title=&quot;1. 马尔科夫随机场&quot;&gt;&lt;/a&gt;1. 马尔科夫随机场&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;场: 在空间的某个区域内, 如果除了个别点以外, 其他的该区域内的每个点p都有一个确定的量 $f(p)$, 那么&lt;strong&gt;该区域&lt;/strong&gt;称为 $f(p)$ 的场。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;随机过程: 设 $T$ 是一无限实数集, 把依赖于 $t \in T$ 的一族(无限多个)随机变量称为随机过程。即为&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;{X(t), t \in T}&lt;/script&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;随机场: 如果 $T$ 是 $n$ 维度空间的一个子集, 即 $t$ 是一个 $n$ 维向量, 此时随机过程称为随机场。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;2-条件随机场CRF-conditional-random-field&quot;&gt;&lt;a href=&quot;#2-条件随机场CRF-conditional-random-field&quot; class=&quot;headerlink&quot; title=&quot;2. 条件随机场CRF (conditional random field)&quot;&gt;&lt;/a&gt;2. 条件随机场CRF (conditional random field)&lt;/h4&gt;&lt;p&gt;定义: 设 $X=(x_1, x_2, …, x_n)$ 和 $Y=(y_1, y_2, …, y_n)$ 均为线性表示的随机变量序列。若在&lt;strong&gt;给定&lt;/strong&gt;随机变量序列&lt;strong&gt;x的条件下&lt;/strong&gt;。 随机变量序列 $Y$ 的条件概率分布 $P(Y|X)$ 构成条件随机场, 并满足马尔科夫性:&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;P(Y_i|X, Y1,...,Y_{i-1},Y_{i+1},...,Y_n) = P(Y_i|X,Y_{i-1},Y_{i+1})&lt;/script&gt;&lt;p&gt;此时称 $P(Y|X)$ 为线性条件随机场。&lt;br&gt;</summary>
    
    
    
    <category term="机器学习" scheme="https://zjcheng.site/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="算法 概率图" scheme="https://zjcheng.site/tags/%E7%AE%97%E6%B3%95-%E6%A6%82%E7%8E%87%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>HMM</title>
    <link href="https://zjcheng.site/2021/03/25/HMM/"/>
    <id>https://zjcheng.site/2021/03/25/HMM/</id>
    <published>2021-03-25T02:37:32.000Z</published>
    <updated>2021-03-25T07:02:20.486Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1- 马尔可夫性"><a href="#1- 马尔可夫性" class="headerlink" title="1. 马尔可夫性"></a>1. 马尔可夫性 </h4><p> 如果某一时刻 $t \geq 1$ 的随机变量 $x_t$ 与其一时刻随机变量 $x_{t-1}$ 之间有条件分布 $P({x_t}|{x_{t-1}})$, 如果 $x_t$ 与 $t-1$ 时刻之前的状态都没有关系, 仅与 $x_{t-1}$ 状态有关, 这一性质成为马尔科夫性质。</p><script type="math/tex; mode=display">P(X_t|X_1, X_2,...,X_t-1) = P(X_t|X_{t-1})</script><h4 id="2- 马尔科夫过程 -or- 马尔科夫链"><a href="#2- 马尔科夫过程 -or- 马尔科夫链" class="headerlink" title="2. 马尔科夫过程 or 马尔科夫链"></a>2. 马尔科夫过程 or 马尔科夫链 </h4><p> 具有马尔科夫性质的序列被成为马尔科夫链条。</p><script type="math/tex; mode=display">X = (X_1, X_2, ..., X_t)</script><h4 id="3- 马尔科夫链中状态的计算"><a href="#3- 马尔科夫链中状态的计算" class="headerlink" title="3. 马尔科夫链中状态的计算"></a>3. 马尔科夫链中状态的计算 </h4><p> 马尔科夫过程中的 <strong> 状态 $t$</strong> 的状态分布概率的计算，它可以由前一时刻 $t-1$ 的状态分布和状态转移矩阵算出来。</p><script type="math/tex; mode=display">\pi(t) = P\pi(t-1) = P(P\pi(t-2)) = P^2\pi(t-2)</script><p>即 <script type="math/tex">\pi(t) = P^t\pi(0)</script></p><span id="more"></span><h4 id="4- 隐马尔科夫模型"><a href="#4- 隐马尔科夫模型" class="headerlink" title="4. 隐马尔科夫模型"></a>4. 隐马尔科夫模型</h4><h5 id="4-1- 假设"><a href="#4-1- 假设" class="headerlink" title="4.1 假设"></a>4.1 假设</h5><ul><li>观测独立假设: <strong>观测 </strong> 只依赖于该时刻的 <strong> 马尔科夫链的状态</strong>, 与其他观测无关。</li><li>马尔科夫性质: 当前状态只与前一状态有关。</li></ul><h5 id="4-2- 组成"><a href="#4-2- 组成" class="headerlink" title="4.2 组成"></a>4.2 组成</h5><ul><li>状态转移矩阵: $A=[a_{ij}]_{N \times N}$, $a_{ij} = P(y_t=s_j|y_{t-1}=s_i)$。表示 $t-1$ 时刻处于状态 $s_i$ 的时候，在 $t$ 时刻处于 $s_j$ 的概率。</li><li>观测概率矩阵: $B=[b_{ij}]_{N \times M}$, $b_{ij} = P(x_t=o_j|y_t=s_i)$。表示在 $t$ 时刻处于状态 $s_i$, 生成观测值 $o_j$ 的概率。</li><li>初始状态概率: $\pi=(\pi_1, \pi_2, …, \pi_N)$, $\pi_i=P(y_1=s_i)$。表示初始状态为 $s_i$ 的概率。</li></ul><h5 id="4-3- 联合概率分布"><a href="#4-3- 联合概率分布" class="headerlink" title="4.3 联合概率分布"></a>4.3 联合概率分布</h5><p>$P(o_1,s_1,…,o_t,s_t) = P(s_1)P(o_1|s_1)\prod_{i=2}^{t}P(s_i|s_{i-1})P(o_i|s_i)$</p><h5 id="4-4- 定义"><a href="#4-4- 定义" class="headerlink" title="4.4 定义"></a>4.4 定义 </h5><p> 通过状态集合 $Q$, 观测集合 $V$, 观测概率矩阵 $B$, 状态转移矩阵 $A$, 初始状态概率向量 $\pi$, 确定一个隐马尔科夫模型，即为:</p><script type="math/tex; mode=display">\lambda = (A, B, \pi)</script><h5 id="4-5- 三个基本问题"><a href="#4-5- 三个基本问题" class="headerlink" title="4.5 三个基本问题"></a>4.5 三个基本问题</h5><ul><li>识别问题(概率计算算法, 也成为前向算法): 给定模型 $\lambda = (A, B, \pi)$ -&gt; 计算模型与观测序列的匹配程度 $P(O|\lambda)$<ul><li>前向算法定义: 输入($\lambda, O$), 输出序列概率 $P(O|\lambda)$</li></ul></li><li>学习问题 (鲍勃 - 韦尔奇算法): 给定观测序列 $O(o_1, o_2, …, o_n)$, 如何训练一个模型 $\lambda = (A, B, \pi)$, 能够使 $P(O|\lambda)$ 最大。</li><li>预测算法(维特比算法, 动态规划算法): 给定 $\lambda = (A, B, \pi)$ 和观测序列 $O(o_1, o_2, …, o_n)$, 如果找到此观测序列最匹配的状态序列 $S = (s_1, s_2, …, s_n)$。 由观测样本得到隐状态。</li></ul><div class="table-container"><table><thead><tr><th>问题</th><th>解决方法</th><th>本质</th></tr></thead><tbody><tr><td>识别问题</td><td>前向算法(Forward Algorithm)</td><td>概率的递推计算</td></tr><tr><td>学习问题</td><td>Baum-Welch Algorithm</td><td>极大似然估计</td></tr><tr><td>解码问题</td><td>Viterbi Algorithm</td><td>动态规划求最优路径</td></tr></tbody></table></div><h5 id="4-6- 局限性"><a href="#4-6- 局限性" class="headerlink" title="4.6 局限性"></a>4.6 局限性</h5><ul><li>状态值存在 <strong> 长距离的依赖</strong></li><li>观测值有非独立的 <strong> 交叉特征</strong></li></ul>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;1-马尔可夫性&quot;&gt;&lt;a href=&quot;#1-马尔可夫性&quot; class=&quot;headerlink&quot; title=&quot;1. 马尔可夫性&quot;&gt;&lt;/a&gt;1. 马尔可夫性&lt;/h4&gt;&lt;p&gt;如果某一时刻$t \geq 1$的随机变量 $x_t$ 与其一时刻随机变量 $x_{t-1}$ 之间有条件分布 $P({x_t}|{x_{t-1}})$, 如果 $x_t$ 与 $t-1$ 时刻之前的状态都没有关系,仅与 $x_{t-1}$ 状态有关, 这一性质成为马尔科夫性质。&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;P(X_t|X_1, X_2,...,X_t-1) = P(X_t|X_{t-1})&lt;/script&gt;&lt;h4 id=&quot;2-马尔科夫过程-or-马尔科夫链&quot;&gt;&lt;a href=&quot;#2-马尔科夫过程-or-马尔科夫链&quot; class=&quot;headerlink&quot; title=&quot;2. 马尔科夫过程 or 马尔科夫链&quot;&gt;&lt;/a&gt;2. 马尔科夫过程 or 马尔科夫链&lt;/h4&gt;&lt;p&gt;具有马尔科夫性质的序列被成为马尔科夫链条。&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;X = (X_1, X_2, ..., X_t)&lt;/script&gt;&lt;h4 id=&quot;3-马尔科夫链中状态的计算&quot;&gt;&lt;a href=&quot;#3-马尔科夫链中状态的计算&quot; class=&quot;headerlink&quot; title=&quot;3. 马尔科夫链中状态的计算&quot;&gt;&lt;/a&gt;3. 马尔科夫链中状态的计算&lt;/h4&gt;&lt;p&gt;马尔科夫过程中的&lt;strong&gt;状态$t$&lt;/strong&gt; 的状态分布概率的计算，它可以由前一时刻$t-1$的状态分布和状态转移矩阵算出来。&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;\pi(t) = P\pi(t-1) = P(P\pi(t-2)) = P^2\pi(t-2)&lt;/script&gt;&lt;p&gt;即 &lt;script type=&quot;math/tex&quot;&gt;\pi(t) = P^t\pi(0)&lt;/script&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="机器学习" scheme="https://zjcheng.site/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="算法 概率图" scheme="https://zjcheng.site/tags/%E7%AE%97%E6%B3%95-%E6%A6%82%E7%8E%87%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>java 基础 - 面向对象</title>
    <link href="https://zjcheng.site/2021/03/23/java%E5%9F%BA%E7%A1%80-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <id>https://zjcheng.site/2021/03/23/java%E5%9F%BA%E7%A1%80-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</id>
    <published>2021-03-23T07:57:46.000Z</published>
    <updated>2021-03-23T07:58:44.627Z</updated>
    
    <content type="html"><![CDATA[<h3 id="重载与重写的区别"><a href="# 重载与重写的区别" class="headerlink" title="重载与重写的区别"></a>重载与重写的区别</h3><hr><div class="table-container"><table><thead><tr><th>类型</th><th>重载</th><th>重写</th></tr></thead><tbody><tr><td>方法名</td><td>一定不能修改</td><td>一定不能修改</td></tr><tr><td>参数列表</td><td>必须修改</td><td>一定不能修改</td></tr><tr><td>返回类型</td><td>可以修改</td><td>可以不同，但必须是父类返回值的派生类</td></tr><tr><td>访问权限</td><td>可以修改</td><td>一定不能做更加严格的显示(可以降低限制)</td></tr><tr><td>抛出异常</td><td>可以修改</td><td>可以减少或者删除，不能抛出新的或者更广的异常</td></tr></tbody></table></div><span id="more"></span><h3 id="抽象类和接口的区别"><a href="# 抽象类和接口的区别" class="headerlink" title="抽象类和接口的区别"></a>抽象类和接口的区别</h3><hr><div class="table-container"><table><thead><tr><th></th><th>abstract class</th><th>interface</th></tr></thead><tbody><tr><td>继承</td><td>只能 extends 一个类</td><td>可以 implements 多个接口</td></tr><tr><td>字段</td><td>可以定义实例字段</td><td>不能定义</td></tr><tr><td>抽象方法</td><td>可以定义抽象方法</td><td>均为抽象方法</td></tr><tr><td>非抽象方法</td><td>可以包含抽象方法</td><td>不能包含</td></tr></tbody></table></div><ul><li>抽象类中可以包含抽象方法和成员变量，但是接口只能含有抽象方法</li><li>它们都是本质上定义接口规范。保证所有子类都有相同的接口规范</li><li>一个实体类只能继承一个抽象类，但是可以实现多个接口</li><li>接口之间的继承使用 extends 关键词</li><li>接口在定义变量时，默认修饰 <code>public static final</code>，可以省去不写</li><li>接口在定义方法是，默认修饰 <code>public abstract</code>, 可以省去。</li></ul><h3 id="访问作用域 -private-protected-public"><a href="# 访问作用域 -private-protected-public" class="headerlink" title="访问作用域 (private, protected, public)"></a> 访问作用域(private, protected, public)</h3><hr><div class="table-container"><table><thead><tr><th></th><th>本类</th><th>同一个包(子类和无关类)</th><th>不同包下(子类)</th><th>不同包下(无关类)</th></tr></thead><tbody><tr><td>private</td><td>Y</td><td>N</td><td>N</td><td>N</td></tr><tr><td>default</td><td>Y</td><td>Y</td><td>N</td><td>N</td></tr><tr><td>protected</td><td>Y</td><td>Y</td><td>Y</td><td>N</td></tr><tr><td>public</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr></tbody></table></div><ul><li>final<ul><li>定义为 final 的类，不能被继承</li><li>定义为 final 的方法，不能被子类重写</li><li>定义为 final 的成员变量，可阻止其被重写赋值</li><li>定义为 final 的局部变量，可阻止其被重写赋值</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;重载与重写的区别&quot;&gt;&lt;a href=&quot;#重载与重写的区别&quot; class=&quot;headerlink&quot; title=&quot;重载与重写的区别&quot;&gt;&lt;/a&gt;重载与重写的区别&lt;/h3&gt;&lt;hr&gt;
&lt;div class=&quot;table-container&quot;&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;重载&lt;/th&gt;
&lt;th&gt;重写&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;方法名&lt;/td&gt;
&lt;td&gt;一定不能修改&lt;/td&gt;
&lt;td&gt;一定不能修改&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;参数列表&lt;/td&gt;
&lt;td&gt;必须修改&lt;/td&gt;
&lt;td&gt;一定不能修改&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;返回类型&lt;/td&gt;
&lt;td&gt;可以修改&lt;/td&gt;
&lt;td&gt;可以不同，但必须是父类返回值的派生类&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;访问权限&lt;/td&gt;
&lt;td&gt;可以修改&lt;/td&gt;
&lt;td&gt;一定不能做更加严格的显示(可以降低限制)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;抛出异常&lt;/td&gt;
&lt;td&gt;可以修改&lt;/td&gt;
&lt;td&gt;可以减少或者删除，不能抛出新的或者更广的异常&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;</summary>
    
    
    
    <category term="编程语言" scheme="https://zjcheng.site/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="Java" scheme="https://zjcheng.site/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java 基础 - 集合</title>
    <link href="https://zjcheng.site/2021/03/23/java%E5%9F%BA%E7%A1%80-%E9%9B%86%E5%90%88/"/>
    <id>https://zjcheng.site/2021/03/23/java%E5%9F%BA%E7%A1%80-%E9%9B%86%E5%90%88/</id>
    <published>2021-03-23T07:35:47.000Z</published>
    <updated>2021-03-23T08:11:54.236Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Stack- 栈，-FILO"><a href="#Stack- 栈，-FILO" class="headerlink" title="Stack (栈， FILO)"></a>Stack (栈， FILO)</h3><hr><ul><li>方法  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;Integer&gt; stk &#x3D; new Stack&lt;&gt;();</span><br><span class="line">(1) 栈顶添加元素: stk.push()</span><br><span class="line">(2) 取出栈顶元素(不删除)： stk.peek()</span><br><span class="line">(3) 取出栈顶元素(并删除)： stk.poll()</span><br></pre></td></tr></table></figure></li></ul><span id="more"></span><h3 id="List- 有序列表的集合"><a href="#List- 有序列表的集合" class="headerlink" title="List (有序列表的集合)"></a>List (有序列表的集合)</h3><hr><ul><li>子类 ArrayList, LinkedList</li><li>方法  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">(1) 添加一个元素： boolean add(val)</span><br><span class="line">(2) 指点索引添加元素： boolean add(idx, val)</span><br><span class="line">(3) 删除某个元素： int remove(val)</span><br><span class="line">(4) 删除指定索引元素：int remove(idx)</span><br><span class="line">(5) 得到列表元素大小：int size()</span><br><span class="line">(6) 得到指定索引元素：int get(idx)</span><br><span class="line">(7) 数组转 list: Integer[] arr &#x3D; &#123;1,2,3&#125;</span><br><span class="line">              List&lt;Integer&gt; list &#x3D; List.of(array)</span><br><span class="line">(8) list 转数组：Object[] arr &#x3D; list.toArray()</span><br><span class="line">              Integer[] arr &#x3D; list.toArray(new Integer[n])</span><br><span class="line">(9) 静态初始化：List&lt;String&gt; list &#x3D; List.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)</span><br><span class="line">(10) 判断是否存在某个元素，通过 equals 判断：list.contains(val)  boolean</span><br><span class="line">(11) 返回某个元素的索引： list.indexOf(val) 如果某有返回 -1</span><br><span class="line">(12) 涉及到自定义类 equals 重写：</span><br><span class="line">        public boolean euqals(Object o)&#123;</span><br><span class="line">            if(o isinstanceof E)&#123;</span><br><span class="line">                 Person p &#x3D; (Person) o; &#x2F;&#x2F;Person 为自定义类，包含 name(引用字段), age(非引用字段)</span><br><span class="line">                &#x2F;&#x2F; 非引用字段调用 &#x3D;&#x3D; 判断</span><br><span class="line">                &#x2F;&#x2F; 引用字段调用 Objects.equals() 判断, 省去 null 值的判断</span><br><span class="line">                return Objects.equals(this.name, p.name) &amp;&amp; this.age&#x3D;&#x3D;p.age;</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li><li>优缺点：<br>  | 属性             |ArrayList|LinkedList|<br>  |——             |——     |——      |<br>  | 得到指定索引元素 | 快       |O(n) 需要重头查找        |<br>  | 尾部插入元素     | 快       | 快 |<br>  | 指定索引插入 / 删除元素 |O(n) 需要移动元素       | 不需要移动元素 |<br>  | 内存占用         | 少       | 大 |</li><li>Iterator 遍历 List 最为高效；实现了 Iterable 的集合类可使用 for each 遍历；</li></ul><h3 id="Set- 没有重复元素的集合"><a href="#Set- 没有重复元素的集合" class="headerlink" title="Set (没有重复元素的集合)"></a>Set (没有重复元素的集合)</h3><hr><ul><li>子类：HashSet(无序), TreeSet(它实现了 SortedSet 接口, 有序)</li><li>方法：  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(1) 添加元素： boolean add(e)</span><br><span class="line">(2) 删除元素： boolean remove(e)</span><br><span class="line">(3) 是否包含某个元素：boolean contains(e)</span><br></pre></td></tr></table></figure></li><li>应用场景：在聊天软件中，发送方发送消息时，遇到网络超时后就会自动重发，因此，接收方可能会收到重复的消息，在显示给用户看的时候，需要首先去重。请练习使用 Set 去除重复的消息</li></ul><h3 id="Map- 通过 key-value 查找的映射表集合 - 不保证顺序"><a href="#Map- 通过 key-value 查找的映射表集合 - 不保证顺序" class="headerlink" title="Map (通过 key-value 查找的映射表集合, 不保证顺序)"></a>Map (通过 key-value 查找的映射表集合, 不保证顺序)</h3><hr><ul><li>子类: HashMap, HashTable, TreeMap(通过实现 Comparator 接口可以保证按照 key 排序), ConcurrentHashMap</li><li>方法：  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">(1) 放入元素：put(key, val) </span><br><span class="line">(2) 重复放入某个 key，覆盖 val 值，返回老的 val 值，如果第一次放入则返回 null</span><br><span class="line">(3) 得到元素：get(key) 如果没有则返回 null</span><br><span class="line">(4) 判断是否含有某个 key: containsKey(key)</span><br><span class="line">(5) 获取 key 的集合： map.keySet()</span><br><span class="line">(6) for-each 遍历：</span><br><span class="line">        1) for(String key: map.keySet())&#123;</span><br><span class="line">              String val &#x3D; map.get(s);</span><br><span class="line">              &#x2F;&#x2F;out(key, val)</span><br><span class="line">           &#125;</span><br><span class="line">        2) for(Map.Entry&lt;String, String&gt; entry: map.entrySet())&#123;</span><br><span class="line">              String key &#x3D; entry.getKey();</span><br><span class="line">              String val &#x3D; entry.getValue();</span><br><span class="line">              &#x2F;&#x2F;out(key, val);</span><br><span class="line">           &#125;</span><br><span class="line">(7) 自定义类中 hashCode() 方法重写：</span><br><span class="line">    int hashCode()&#123;</span><br><span class="line">        return Objects.hashCode(firstName, lastName, age) &#x2F;&#x2F; 参数为成员变量</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li>特点：<ul><li>常用于频繁查询内容，作为缓存 cache, 提高查询效率。</li><li>其内部 key 的比较采用的是 equals 方法</li><li>其内部 key 对应的索引计算方法 hashCode()，返回值为 int。</li><li>为了保证 Map 能够正常运行需要正确覆盖 equals() 和 hashCode() 方法。</li><li>Map 首先通过计算 key 的 hashCode()得到内部索引位置，如果不同 key 的 hashCoder()相同(哈希冲突)，再次遍历 list, 因为其内部其实存储的为 List<Entry<String, Person>&gt; 列表，不单单是一个 Person.</li></ul></li></ul><h3 id="自定义类变为可比较类型的三种方法 - 这里以 Person 自定义类举例 - 按照 age 从小到大排序"><a href="# 自定义类变为可比较类型的三种方法 - 这里以 Person 自定义类举例 - 按照 age 从小到大排序" class="headerlink" title="自定义类变为可比较类型的三种方法 (这里以 Person 自定义类举例, 按照 age 从小到大排序)"></a> 自定义类变为可比较类型的三种方法(这里以 Person 自定义类举例, 按照 age 从小到大排序)</h3><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">(1) 自定义类实现 Comparable 接口</span><br><span class="line">class Person implements Comparable&#123;</span><br><span class="line">    String name;</span><br><span class="line">    int age;</span><br><span class="line">    public Perosn(int age, String name)&#123;</span><br><span class="line">        this.age &#x3D; age;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public int compareTo(Object o)&#123;</span><br><span class="line">        if(o instanceof Person)&#123;</span><br><span class="line">            Person p &#x3D; (Person)o;</span><br><span class="line">            if(this.age&#x3D;&#x3D;p.age) return 0;</span><br><span class="line">            return this.age&lt;p.age? -1: 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">TreeSet&lt;Person&gt; set &#x3D; new TreeSet&lt;&gt;();</span><br><span class="line">set.add(new Person(20, &quot;Bob&quot;));</span><br><span class="line">set.add(new Person(21, &quot;Aim&quot;));</span><br><span class="line">set.add(new Person(22, &quot;John&quot;));</span><br><span class="line"></span><br><span class="line">(2) 匿名函数 Comparator</span><br><span class="line">TreeSet&lt;Person&gt; set &#x3D; new TreeSet&lt;&gt;(new Comparator&lt;Person&gt;(</span><br><span class="line">    @Override</span><br><span class="line">    public int compare(Person a, Person b)&#123;</span><br><span class="line">        if(a.age&#x3D;&#x3D;b.age) return 0;</span><br><span class="line">        return a.age&lt;b.age? -1: 1;</span><br><span class="line">    &#125;</span><br><span class="line">));</span><br><span class="line"></span><br><span class="line">(3) 实现自定义类 Comparator</span><br><span class="line">class MyComparator implements Comparator&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int compare(Object a, Object b)&#123;</span><br><span class="line">        Person a &#x3D; (Person)a;</span><br><span class="line">        Person b &#x3D; (Person)b;</span><br><span class="line">        if(a.age&#x3D;&#x3D;b.age) return 0;</span><br><span class="line">        return a.age&lt;b.age? -1: 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Queue- 队列，-FIFO"><a href="#Queue- 队列，-FIFO" class="headerlink" title="Queue (队列， FIFO)"></a>Queue (队列， FIFO)</h3><hr><ul><li>常用实现类：  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;String&gt; que &#x3D; new LinkedList&lt;&gt;()</span><br><span class="line">Queue&lt;String&gt; que &#x3D; new PriorityQueue&lt;&gt;() &#x2F;&#x2F; 优先队列， 其内部元素不许实现 Comparable 接口</span><br></pre></td></tr></table></figure></li><li>方法：  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(1) 获取队列长度：size()</span><br><span class="line">(2) 队尾添加元素：add() &#x2F; offer()  boolean</span><br><span class="line">(3) 队头删除元素：remove() &#x2F; poll() 返回元素类型</span><br><span class="line">(4) 获取队头元素但不删除： element() &#x2F; peek()</span><br></pre></td></tr></table></figure></li></ul><h3 id="Deque- 双端队列，两端插入"><a href="#Deque- 双端队列，两端插入" class="headerlink" title="Deque (双端队列，两端插入)"></a>Deque (双端队列，两端插入)</h3><hr><ul><li>常用实现类：  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;String&gt; que &#x3D; new LinkedList&lt;&gt;()</span><br></pre></td></tr></table></figure></li><li>方法 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(1) 队头 &#x2F; 队尾 添加元素：addFirst(), offerFirst() &#x2F; addLast(), offerFirst()</span><br><span class="line">(2) 队头 &#x2F; 队尾 删除元素：removeFirst(), pollFirst() &#x2F; removeLast(), pollLast()</span><br><span class="line">(3) 队头 &#x2F; 队尾 取出元素：getFirst(), peekFirst() &#x2F; getLast(), peekLast()</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;Stack-栈，-FILO&quot;&gt;&lt;a href=&quot;#Stack-栈，-FILO&quot; class=&quot;headerlink&quot; title=&quot;Stack (栈， FILO)&quot;&gt;&lt;/a&gt;Stack (栈， FILO)&lt;/h3&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;方法  &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Stack&amp;lt;Integer&amp;gt; stk &amp;#x3D; new Stack&amp;lt;&amp;gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(1) 栈顶添加元素: stk.push()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(2) 取出栈顶元素(不删除)： stk.peek()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(3) 取出栈顶元素(并删除)： stk.poll()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="编程语言" scheme="https://zjcheng.site/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="Java" scheme="https://zjcheng.site/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>热爱生命</title>
    <link href="https://zjcheng.site/2021/03/11/%E7%83%AD%E7%88%B1%E7%94%9F%E5%91%BD/"/>
    <id>https://zjcheng.site/2021/03/11/%E7%83%AD%E7%88%B1%E7%94%9F%E5%91%BD/</id>
    <published>2021-03-11T12:15:42.000Z</published>
    <updated>2021-03-11T13:00:37.286Z</updated>
    
    <content type="html"><![CDATA[<center><h1> 热爱生命 </h1><p>我不去想，<br>是否能够成功 ，<br>既然选择了远方 ，<br>便只顾风雨兼程。<br></p><span id="more"></span><p>我不去想，<br>能否赢得爱情 ，<br>既然钟情于玫瑰 ，<br>就勇敢地吐露真诚 。<br></p><p>我不去想，<br>身后会不会袭来寒风冷雨 ，<br>既然目标是地平线，<br>留给世界的只能是背影 。<br></p><p>我不去想，<br>未来是平坦还是泥泞 ，<br>只要热爱生命 </font>，<br>一切，都在意料之中。</p></center>]]></content>
    
    
    <summary type="html">&lt;center&gt;
&lt;h1&gt;热爱生命&lt;/h1&gt;
&lt;p&gt;
我不去想，&lt;br&gt;
是否能够成功 ，&lt;br&gt;
既然选择了远方 ，&lt;br&gt;
便只顾风雨兼程。&lt;br&gt;
&lt;/p&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://zjcheng.site/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="诗歌" scheme="https://zjcheng.site/tags/%E8%AF%97%E6%AD%8C/"/>
    
  </entry>
  
</feed>
