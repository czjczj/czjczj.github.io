<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>热爱生命</title>
    <url>/2021/03/11/%E7%83%AD%E7%88%B1%E7%94%9F%E5%91%BD/</url>
    <content><![CDATA[<center>
<h1> 热爱生命 </h1>
<p>
我不去想，<br>
是否能够成功 ，<br>
既然选择了远方 ，<br>
便只顾风雨兼程。<br>
</p>
<span id="more"></span>
<p>
我不去想，<br>
能否赢得爱情 ，<br>
既然钟情于玫瑰 ，<br>
就勇敢地吐露真诚 。<br>
</p>

<p>
我不去想，<br>
身后会不会袭来寒风冷雨 ，<br>
既然目标是地平线，<br>
留给世界的只能是背影 。<br>
</p>

<p>
我不去想，<br>
未来是平坦还是泥泞 ，<br>
只要热爱生命 </font>，<br>
一切，都在意料之中。
</p>
</center>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>诗歌</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 基础 - 集合</title>
    <url>/2021/03/23/java%E5%9F%BA%E7%A1%80-%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h3 id="List- 有序列表的集合"><a href="#List- 有序列表的集合" class="headerlink" title="List (有序列表的集合)"></a>List (有序列表的集合)</h3><hr>
<ul>
<li>子类 ArrayList, LinkedList</li>
<li>方法  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(1) 添加一个元素： boolean add(val)</span><br><span class="line">(2) 指点索引添加元素： boolean add(idx, val)</span><br><span class="line">(3) 删除某个元素： int remove(val)</span><br><span class="line">(4) 删除指定索引元素：int remove(idx)</span><br><span class="line">(5) 得到列表元素大小：int size()</span><br><span class="line">(6) 得到指定索引元素：int get(idx)</span><br><span class="line">(7) 数组转 list: Integer[] arr &#x3D; &#123;1,2,3&#125;</span><br><span class="line">              List&lt;Integer&gt; list &#x3D; List.of(array)</span><br><span class="line">(8) list 转数组：Object[] arr &#x3D; list.toArray()</span><br><span class="line">              Integer[] arr &#x3D; list.toArray(new Integer[n])</span><br><span class="line">(9) 静态初始化：List&lt;String&gt; list &#x3D; List.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)</span><br><span class="line">(10) 判断是否存在某个元素，通过 equals 判断：list.contains(val)  boolean</span><br><span class="line">(11) 返回某个元素的索引： list.indexOf(val) 如果某有返回 -1</span><br><span class="line">(12) 涉及到自定义类 equals 重写：</span><br><span class="line">        public boolean euqals(Object o)&#123;</span><br><span class="line">            if(o isinstanceof E)&#123;</span><br><span class="line">                 Person p &#x3D; (Person) o; &#x2F;&#x2F;Person 为自定义类，包含 name(引用字段), age(非引用字段)</span><br><span class="line">                &#x2F;&#x2F; 非引用字段调用 &#x3D;&#x3D; 判断</span><br><span class="line">                &#x2F;&#x2F; 引用字段调用 Objects.equals() 判断, 省去 null 值的判断</span><br><span class="line">                return Objects.equals(this.name, p.name) &amp;&amp; this.age&#x3D;&#x3D;p.age;</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span></li>
<li>优缺点：<table>
<thead>
<tr>
<th>属性</th>
<th>ArrayList</th>
<th>LinkedList</th>
</tr>
</thead>
<tbody><tr>
<td>得到指定索引元素</td>
<td>快</td>
<td>O(n) 需要重头查找</td>
</tr>
<tr>
<td>尾部插入元素</td>
<td>快</td>
<td>快</td>
</tr>
<tr>
<td>指定索引插入 / 删除元素</td>
<td>O(n) 需要移动元素</td>
<td>不需要移动元素</td>
</tr>
<tr>
<td>内存占用</td>
<td>少</td>
<td>大</td>
</tr>
</tbody></table>
</li>
<li>Iterator 遍历 List 最为高效；实现了 Iterable 的集合类可使用 for each 遍历；</li>
</ul>
<h3 id="Set- 没有重复元素的集合"><a href="#Set- 没有重复元素的集合" class="headerlink" title="Set (没有重复元素的集合)"></a>Set (没有重复元素的集合)</h3><hr>
<ul>
<li>子类：HashSet(无序), TreeSet(它实现了 SortedSet 接口, 有序)</li>
<li>方法：  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(1) 添加元素： boolean add(e)</span><br><span class="line">(2) 删除元素： boolean remove(e)</span><br><span class="line">(3) 是否包含某个元素：boolean contains(e)</span><br></pre></td></tr></table></figure></li>
<li>应用场景：在聊天软件中，发送方发送消息时，遇到网络超时后就会自动重发，因此，接收方可能会收到重复的消息，在显示给用户看的时候，需要首先去重。请练习使用 Set 去除重复的消息</li>
</ul>
<h3 id="Map- 通过 key-value 查找的映射表集合 - 不保证顺序"><a href="#Map- 通过 key-value 查找的映射表集合 - 不保证顺序" class="headerlink" title="Map (通过 key-value 查找的映射表集合, 不保证顺序)"></a>Map (通过 key-value 查找的映射表集合, 不保证顺序)</h3><hr>
<ul>
<li>子类: HashMap, HashTable, TreeMap(通过实现 Comparator 接口可以保证按照 key 排序), ConcurrentHashMap</li>
<li>方法：  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(1) 放入元素：put(key, val) </span><br><span class="line">(2) 重复放入某个 key，覆盖 val 值，返回老的 val 值，如果第一次放入则返回 null</span><br><span class="line">(3) 得到元素：get(key) 如果没有则返回 null</span><br><span class="line">(4) 判断是否含有某个 key: containsKey(key)</span><br><span class="line">(5) 获取 key 的集合： map.keySet()</span><br><span class="line">(6) for-each 遍历：</span><br><span class="line">        1) for(String key: map.keySet())&#123;</span><br><span class="line">              String val &#x3D; map.get(s);</span><br><span class="line">              &#x2F;&#x2F;out(key, val)</span><br><span class="line">           &#125;</span><br><span class="line">        2) for(Map.Entry&lt;String, String&gt; entry: map.entrySet())&#123;</span><br><span class="line">              String key &#x3D; entry.getKey();</span><br><span class="line">              String val &#x3D; entry.getValue();</span><br><span class="line">              &#x2F;&#x2F;out(key, val);</span><br><span class="line">           &#125;</span><br><span class="line">(7) 自定义类中 hashCode() 方法重写：</span><br><span class="line">    int hashCode()&#123;</span><br><span class="line">        return Objects.hashCode(firstName, lastName, age) &#x2F;&#x2F; 参数为成员变量</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li>特点：<ul>
<li>常用于频繁查询内容，作为缓存 cache, 提高查询效率。</li>
<li>其内部 key 的比较采用的是 equals 方法</li>
<li>其内部 key 对应的索引计算方法 hashCode()，返回值为 int。</li>
<li>为了保证 Map 能够正常运行需要正确覆盖 equals() 和 hashCode() 方法。</li>
<li>Map 首先通过计算 key 的 hashCode()得到内部索引位置，如果不同 key 的 hashCoder()相同(哈希冲突)，再次遍历 list, 因为其内部其实存储的为 List&lt;Entry&lt;String, Person&gt;&gt; 列表，不单单是一个 Person.</li>
</ul>
</li>
</ul>
<h3 id="自定义类变为可比较类型的三种方法 - 这里以 Person 自定义类举例 - 按照 age 从小到大排序"><a href="# 自定义类变为可比较类型的三种方法 - 这里以 Person 自定义类举例 - 按照 age 从小到大排序" class="headerlink" title="自定义类变为可比较类型的三种方法 (这里以 Person 自定义类举例, 按照 age 从小到大排序)"></a> 自定义类变为可比较类型的三种方法(这里以 Person 自定义类举例, 按照 age 从小到大排序)</h3><hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(1) 自定义类实现 Comparable 接口</span><br><span class="line">class Person implements Comparable&#123;</span><br><span class="line">    String name;</span><br><span class="line">    int age;</span><br><span class="line">    public Perosn(int age, String name)&#123;</span><br><span class="line">        this.age &#x3D; age;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public int compareTo(Object o)&#123;</span><br><span class="line">        if(o instanceof Person)&#123;</span><br><span class="line">            Person p &#x3D; (Person)o;</span><br><span class="line">            if(this.age&#x3D;&#x3D;p.age) return 0;</span><br><span class="line">            return this.age&lt;p.age? -1: 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">TreeSet&lt;Person&gt; set &#x3D; new TreeSet&lt;&gt;();</span><br><span class="line">set.add(new Person(20, &quot;Bob&quot;));</span><br><span class="line">set.add(new Person(21, &quot;Aim&quot;));</span><br><span class="line">set.add(new Person(22, &quot;John&quot;));</span><br><span class="line"></span><br><span class="line">(2) 匿名函数 Comparator</span><br><span class="line">TreeSet&lt;Person&gt; set &#x3D; new TreeSet&lt;&gt;(new Comparator&lt;Person&gt;(</span><br><span class="line">    @Override</span><br><span class="line">    public int compare(Person a, Person b)&#123;</span><br><span class="line">        if(a.age&#x3D;&#x3D;b.age) return 0;</span><br><span class="line">        return a.age&lt;b.age? -1: 1;</span><br><span class="line">    &#125;</span><br><span class="line">));</span><br><span class="line"></span><br><span class="line">(3) 实现自定义类 Comparator</span><br><span class="line">class MyComparator implements Comparator&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int compare(Object a, Object b)&#123;</span><br><span class="line">        Person a &#x3D; (Person)a;</span><br><span class="line">        Person b &#x3D; (Person)b;</span><br><span class="line">        if(a.age&#x3D;&#x3D;b.age) return 0;</span><br><span class="line">        return a.age&lt;b.age? -1: 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Queue- 队列，-FIFO"><a href="#Queue- 队列，-FIFO" class="headerlink" title="Queue (队列， FIFO)"></a>Queue (队列， FIFO)</h3><hr>
<ul>
<li>常用实现类：  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Queue&lt;String&gt; que &#x3D; new LinkedList&lt;&gt;()</span><br><span class="line">Queue&lt;String&gt; que &#x3D; new PriorityQueue&lt;&gt;() &#x2F;&#x2F; 优先队列， 其内部元素不许实现 Comparable 接口</span><br></pre></td></tr></table></figure></li>
<li>方法：  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(1) 获取队列长度：size()</span><br><span class="line">(2) 队尾添加元素：add() &#x2F; offer()  boolean</span><br><span class="line">(3) 队头删除元素：remove() &#x2F; poll() 返回元素类型</span><br><span class="line">(4) 获取队头元素但不删除： element() &#x2F; peek()</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Deque- 双端队列，两端插入"><a href="#Deque- 双端队列，两端插入" class="headerlink" title="Deque (双端队列，两端插入)"></a>Deque (双端队列，两端插入)</h3><hr>
<ul>
<li>常用实现类：  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Deque&lt;String&gt; que &#x3D; new LinkedList&lt;&gt;()</span><br></pre></td></tr></table></figure></li>
<li>方法 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(1) 队头 &#x2F; 队尾 添加元素：addFirst(), offerFirst() &#x2F; addLast(), offerFirst()</span><br><span class="line">(2) 队头 &#x2F; 队尾 删除元素：removeFirst(), pollFirst() &#x2F; removeLast(), pollLast()</span><br><span class="line">(3) 队头 &#x2F; 队尾 取出元素：getFirst(), peekFirst() &#x2F; getLast(), peekLast()</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Stack- 栈，-FILO"><a href="#Stack- 栈，-FILO" class="headerlink" title="Stack (栈， FILO)"></a>Stack (栈， FILO)</h3><hr>
<ul>
<li>方法  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Stack&lt;Integer&gt; stk &#x3D; new Stack&lt;&gt;();</span><br><span class="line">(1) 栈顶添加元素: stk.push()</span><br><span class="line">(2) 取出栈顶元素(不删除)： stk.peek()</span><br><span class="line">(3) 取出栈顶元素(并删除)： stk.poll()</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>java 基础 - 面向对象</title>
    <url>/2021/03/23/java%E5%9F%BA%E7%A1%80-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h3 id="重载与重写的区别"><a href="# 重载与重写的区别" class="headerlink" title="重载与重写的区别"></a>重载与重写的区别</h3><hr>
<table>
<thead>
<tr>
<th>类型</th>
<th>重载</th>
<th>重写</th>
</tr>
</thead>
<tbody><tr>
<td>方法名</td>
<td>一定不能修改</td>
<td>一定不能修改</td>
</tr>
<tr>
<td>参数列表</td>
<td>必须修改</td>
<td>一定不能修改</td>
</tr>
<tr>
<td>返回类型</td>
<td>可以修改</td>
<td>可以不同，但必须是父类返回值的派生类</td>
</tr>
<tr>
<td>访问权限</td>
<td>可以修改</td>
<td>一定不能做更加严格的显示(可以降低限制)</td>
</tr>
<tr>
<td>抛出异常</td>
<td>可以修改</td>
<td>可以减少或者删除，不能抛出新的或者更广的异常</td>
</tr>
</tbody></table>
<span id="more"></span>

<h3 id="抽象类和接口的区别"><a href="# 抽象类和接口的区别" class="headerlink" title="抽象类和接口的区别"></a>抽象类和接口的区别</h3><hr>
<table>
<thead>
<tr>
<th></th>
<th>abstract class</th>
<th>interface</th>
</tr>
</thead>
<tbody><tr>
<td>继承</td>
<td>只能 extends 一个类</td>
<td>可以 implements 多个接口</td>
</tr>
<tr>
<td>字段</td>
<td>可以定义实例字段</td>
<td>不能定义</td>
</tr>
<tr>
<td>抽象方法</td>
<td>可以定义抽象方法</td>
<td>均为抽象方法</td>
</tr>
<tr>
<td>非抽象方法</td>
<td>可以包含抽象方法</td>
<td>不能包含</td>
</tr>
</tbody></table>
<ul>
<li>抽象类中可以包含抽象方法和成员变量，但是接口只能含有抽象方法</li>
<li>它们都是本质上定义接口规范。保证所有子类都有相同的接口规范</li>
<li>一个实体类只能继承一个抽象类，但是可以实现多个接口</li>
<li>接口之间的继承使用 extends 关键词</li>
<li>接口在定义变量时，默认修饰 <code>public static final</code>，可以省去不写</li>
<li>接口在定义方法是，默认修饰 <code>public abstract</code>, 可以省去。</li>
</ul>
<h3 id="访问作用域 -private-protected-public"><a href="# 访问作用域 -private-protected-public" class="headerlink" title="访问作用域 (private, protected, public)"></a> 访问作用域(private, protected, public)</h3><hr>
<table>
<thead>
<tr>
<th></th>
<th>本类</th>
<th>同一个包(子类和无关类)</th>
<th>不同包下(子类)</th>
<th>不同包下(无关类)</th>
</tr>
</thead>
<tbody><tr>
<td>private</td>
<td>Y</td>
<td>N</td>
<td>N</td>
<td>N</td>
</tr>
<tr>
<td>default</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
<td>N</td>
</tr>
<tr>
<td>protected</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>public</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
</tbody></table>
<ul>
<li>final<ul>
<li>定义为 final 的类，不能被继承</li>
<li>定义为 final 的方法，不能被子类重写</li>
<li>定义为 final 的成员变量，可阻止其被重写赋值</li>
<li>定义为 final 的局部变量，可阻止其被重写赋值</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
</search>
