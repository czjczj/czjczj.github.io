<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>热爱生命</title>
    <url>/2021/03/11/%E7%83%AD%E7%88%B1%E7%94%9F%E5%91%BD/</url>
    <content><![CDATA[<center>
<h1> 热爱生命 </h1>
<p>
我不去想，<br>
是否能够成功 ，<br>
既然选择了远方 ，<br>
便只顾风雨兼程。<br>
</p>
<span id="more"></span>
<p>
我不去想，<br>
能否赢得爱情 ，<br>
既然钟情于玫瑰 ，<br>
就勇敢地吐露真诚 。<br>
</p>

<p>
我不去想，<br>
身后会不会袭来寒风冷雨 ，<br>
既然目标是地平线，<br>
留给世界的只能是背影 。<br>
</p>

<p>
我不去想，<br>
未来是平坦还是泥泞 ，<br>
只要热爱生命 </font>，<br>
一切，都在意料之中。
</p>
</center>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>诗歌</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 基础 - 集合</title>
    <url>/2021/03/23/java%E5%9F%BA%E7%A1%80-%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h3 id="Stack- 栈，-FILO"><a href="#Stack- 栈，-FILO" class="headerlink" title="Stack (栈， FILO)"></a>Stack (栈， FILO)</h3><hr>
<ul>
<li>方法  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Stack&lt;Integer&gt; stk &#x3D; new Stack&lt;&gt;();</span><br><span class="line">(1) 栈顶添加元素: stk.push()</span><br><span class="line">(2) 取出栈顶元素(不删除)： stk.peek()</span><br><span class="line">(3) 取出栈顶元素(并删除)： stk.poll()</span><br></pre></td></tr></table></figure></li>
</ul>
<span id="more"></span>
<h3 id="List- 有序列表的集合"><a href="#List- 有序列表的集合" class="headerlink" title="List (有序列表的集合)"></a>List (有序列表的集合)</h3><hr>
<ul>
<li>子类 ArrayList, LinkedList</li>
<li>方法  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(1) 添加一个元素： boolean add(val)</span><br><span class="line">(2) 指点索引添加元素： boolean add(idx, val)</span><br><span class="line">(3) 删除某个元素： int remove(val)</span><br><span class="line">(4) 删除指定索引元素：int remove(idx)</span><br><span class="line">(5) 得到列表元素大小：int size()</span><br><span class="line">(6) 得到指定索引元素：int get(idx)</span><br><span class="line">(7) 数组转 list: Integer[] arr &#x3D; &#123;1,2,3&#125;</span><br><span class="line">              List&lt;Integer&gt; list &#x3D; List.of(array)</span><br><span class="line">(8) list 转数组：Object[] arr &#x3D; list.toArray()</span><br><span class="line">              Integer[] arr &#x3D; list.toArray(new Integer[n])</span><br><span class="line">(9) 静态初始化：List&lt;String&gt; list &#x3D; List.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)</span><br><span class="line">(10) 判断是否存在某个元素，通过 equals 判断：list.contains(val)  boolean</span><br><span class="line">(11) 返回某个元素的索引： list.indexOf(val) 如果某有返回 -1</span><br><span class="line">(12) 涉及到自定义类 equals 重写：</span><br><span class="line">        public boolean euqals(Object o)&#123;</span><br><span class="line">            if(o isinstanceof E)&#123;</span><br><span class="line">                 Person p &#x3D; (Person) o; &#x2F;&#x2F;Person 为自定义类，包含 name(引用字段), age(非引用字段)</span><br><span class="line">                &#x2F;&#x2F; 非引用字段调用 &#x3D;&#x3D; 判断</span><br><span class="line">                &#x2F;&#x2F; 引用字段调用 Objects.equals() 判断, 省去 null 值的判断</span><br><span class="line">                return Objects.equals(this.name, p.name) &amp;&amp; this.age&#x3D;&#x3D;p.age;</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li>
<li>优缺点：<table>
<thead>
<tr>
<th>属性</th>
<th>ArrayList</th>
<th>LinkedList</th>
</tr>
</thead>
<tbody><tr>
<td>得到指定索引元素</td>
<td>快</td>
<td>O(n) 需要重头查找</td>
</tr>
<tr>
<td>尾部插入元素</td>
<td>快</td>
<td>快</td>
</tr>
<tr>
<td>指定索引插入 / 删除元素</td>
<td>O(n) 需要移动元素</td>
<td>不需要移动元素</td>
</tr>
<tr>
<td>内存占用</td>
<td>少</td>
<td>大</td>
</tr>
</tbody></table>
</li>
<li>Iterator 遍历 List 最为高效；实现了 Iterable 的集合类可使用 for each 遍历；</li>
</ul>
<h3 id="Set- 没有重复元素的集合"><a href="#Set- 没有重复元素的集合" class="headerlink" title="Set (没有重复元素的集合)"></a>Set (没有重复元素的集合)</h3><hr>
<ul>
<li>子类：HashSet(无序), TreeSet(它实现了 SortedSet 接口, 有序)</li>
<li>方法：  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(1) 添加元素： boolean add(e)</span><br><span class="line">(2) 删除元素： boolean remove(e)</span><br><span class="line">(3) 是否包含某个元素：boolean contains(e)</span><br></pre></td></tr></table></figure></li>
<li>应用场景：在聊天软件中，发送方发送消息时，遇到网络超时后就会自动重发，因此，接收方可能会收到重复的消息，在显示给用户看的时候，需要首先去重。请练习使用 Set 去除重复的消息</li>
</ul>
<h3 id="Map- 通过 key-value 查找的映射表集合 - 不保证顺序"><a href="#Map- 通过 key-value 查找的映射表集合 - 不保证顺序" class="headerlink" title="Map (通过 key-value 查找的映射表集合, 不保证顺序)"></a>Map (通过 key-value 查找的映射表集合, 不保证顺序)</h3><hr>
<ul>
<li>子类: HashMap, HashTable, TreeMap(通过实现 Comparator 接口可以保证按照 key 排序), ConcurrentHashMap</li>
<li>方法：  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(1) 放入元素：put(key, val) </span><br><span class="line">(2) 重复放入某个 key，覆盖 val 值，返回老的 val 值，如果第一次放入则返回 null</span><br><span class="line">(3) 得到元素：get(key) 如果没有则返回 null</span><br><span class="line">(4) 判断是否含有某个 key: containsKey(key)</span><br><span class="line">(5) 获取 key 的集合： map.keySet()</span><br><span class="line">(6) for-each 遍历：</span><br><span class="line">        1) for(String key: map.keySet())&#123;</span><br><span class="line">              String val &#x3D; map.get(s);</span><br><span class="line">              &#x2F;&#x2F;out(key, val)</span><br><span class="line">           &#125;</span><br><span class="line">        2) for(Map.Entry&lt;String, String&gt; entry: map.entrySet())&#123;</span><br><span class="line">              String key &#x3D; entry.getKey();</span><br><span class="line">              String val &#x3D; entry.getValue();</span><br><span class="line">              &#x2F;&#x2F;out(key, val);</span><br><span class="line">           &#125;</span><br><span class="line">(7) 自定义类中 hashCode() 方法重写：</span><br><span class="line">    int hashCode()&#123;</span><br><span class="line">        return Objects.hashCode(firstName, lastName, age) &#x2F;&#x2F; 参数为成员变量</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li>特点：<ul>
<li>常用于频繁查询内容，作为缓存 cache, 提高查询效率。</li>
<li>其内部 key 的比较采用的是 equals 方法</li>
<li>其内部 key 对应的索引计算方法 hashCode()，返回值为 int。</li>
<li>为了保证 Map 能够正常运行需要正确覆盖 equals() 和 hashCode() 方法。</li>
<li>Map 首先通过计算 key 的 hashCode()得到内部索引位置，如果不同 key 的 hashCoder()相同(哈希冲突)，再次遍历 list, 因为其内部其实存储的为 List&lt;Entry&lt;String, Person&gt;&gt; 列表，不单单是一个 Person.</li>
</ul>
</li>
</ul>
<h3 id="自定义类变为可比较类型的三种方法 - 这里以 Person 自定义类举例 - 按照 age 从小到大排序"><a href="# 自定义类变为可比较类型的三种方法 - 这里以 Person 自定义类举例 - 按照 age 从小到大排序" class="headerlink" title="自定义类变为可比较类型的三种方法 (这里以 Person 自定义类举例, 按照 age 从小到大排序)"></a> 自定义类变为可比较类型的三种方法(这里以 Person 自定义类举例, 按照 age 从小到大排序)</h3><hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(1) 自定义类实现 Comparable 接口</span><br><span class="line">class Person implements Comparable&#123;</span><br><span class="line">    String name;</span><br><span class="line">    int age;</span><br><span class="line">    public Perosn(int age, String name)&#123;</span><br><span class="line">        this.age &#x3D; age;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public int compareTo(Object o)&#123;</span><br><span class="line">        if(o instanceof Person)&#123;</span><br><span class="line">            Person p &#x3D; (Person)o;</span><br><span class="line">            if(this.age&#x3D;&#x3D;p.age) return 0;</span><br><span class="line">            return this.age&lt;p.age? -1: 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">TreeSet&lt;Person&gt; set &#x3D; new TreeSet&lt;&gt;();</span><br><span class="line">set.add(new Person(20, &quot;Bob&quot;));</span><br><span class="line">set.add(new Person(21, &quot;Aim&quot;));</span><br><span class="line">set.add(new Person(22, &quot;John&quot;));</span><br><span class="line"></span><br><span class="line">(2) 匿名函数 Comparator</span><br><span class="line">TreeSet&lt;Person&gt; set &#x3D; new TreeSet&lt;&gt;(new Comparator&lt;Person&gt;(</span><br><span class="line">    @Override</span><br><span class="line">    public int compare(Person a, Person b)&#123;</span><br><span class="line">        if(a.age&#x3D;&#x3D;b.age) return 0;</span><br><span class="line">        return a.age&lt;b.age? -1: 1;</span><br><span class="line">    &#125;</span><br><span class="line">));</span><br><span class="line"></span><br><span class="line">(3) 实现自定义类 Comparator</span><br><span class="line">class MyComparator implements Comparator&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int compare(Object a, Object b)&#123;</span><br><span class="line">        Person a &#x3D; (Person)a;</span><br><span class="line">        Person b &#x3D; (Person)b;</span><br><span class="line">        if(a.age&#x3D;&#x3D;b.age) return 0;</span><br><span class="line">        return a.age&lt;b.age? -1: 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Queue- 队列，-FIFO"><a href="#Queue- 队列，-FIFO" class="headerlink" title="Queue (队列， FIFO)"></a>Queue (队列， FIFO)</h3><hr>
<ul>
<li>常用实现类：  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Queue&lt;String&gt; que &#x3D; new LinkedList&lt;&gt;()</span><br><span class="line">Queue&lt;String&gt; que &#x3D; new PriorityQueue&lt;&gt;() &#x2F;&#x2F; 优先队列， 其内部元素不许实现 Comparable 接口</span><br></pre></td></tr></table></figure></li>
<li>方法：  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(1) 获取队列长度：size()</span><br><span class="line">(2) 队尾添加元素：add() &#x2F; offer()  boolean</span><br><span class="line">(3) 队头删除元素：remove() &#x2F; poll() 返回元素类型</span><br><span class="line">(4) 获取队头元素但不删除： element() &#x2F; peek()</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Deque- 双端队列，两端插入"><a href="#Deque- 双端队列，两端插入" class="headerlink" title="Deque (双端队列，两端插入)"></a>Deque (双端队列，两端插入)</h3><hr>
<ul>
<li>常用实现类：  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Deque&lt;String&gt; que &#x3D; new LinkedList&lt;&gt;()</span><br></pre></td></tr></table></figure></li>
<li>方法 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(1) 队头 &#x2F; 队尾 添加元素：addFirst(), offerFirst() &#x2F; addLast(), offerFirst()</span><br><span class="line">(2) 队头 &#x2F; 队尾 删除元素：removeFirst(), pollFirst() &#x2F; removeLast(), pollLast()</span><br><span class="line">(3) 队头 &#x2F; 队尾 取出元素：getFirst(), peekFirst() &#x2F; getLast(), peekLast()</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>java 基础 - 面向对象</title>
    <url>/2021/03/23/java%E5%9F%BA%E7%A1%80-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h3 id="重载与重写的区别"><a href="# 重载与重写的区别" class="headerlink" title="重载与重写的区别"></a>重载与重写的区别</h3><hr>
<table>
<thead>
<tr>
<th>类型</th>
<th>重载</th>
<th>重写</th>
</tr>
</thead>
<tbody><tr>
<td>方法名</td>
<td>一定不能修改</td>
<td>一定不能修改</td>
</tr>
<tr>
<td>参数列表</td>
<td>必须修改</td>
<td>一定不能修改</td>
</tr>
<tr>
<td>返回类型</td>
<td>可以修改</td>
<td>可以不同，但必须是父类返回值的派生类</td>
</tr>
<tr>
<td>访问权限</td>
<td>可以修改</td>
<td>一定不能做更加严格的显示(可以降低限制)</td>
</tr>
<tr>
<td>抛出异常</td>
<td>可以修改</td>
<td>可以减少或者删除，不能抛出新的或者更广的异常</td>
</tr>
</tbody></table>
<span id="more"></span>

<h3 id="抽象类和接口的区别"><a href="# 抽象类和接口的区别" class="headerlink" title="抽象类和接口的区别"></a>抽象类和接口的区别</h3><hr>
<table>
<thead>
<tr>
<th></th>
<th>abstract class</th>
<th>interface</th>
</tr>
</thead>
<tbody><tr>
<td>继承</td>
<td>只能 extends 一个类</td>
<td>可以 implements 多个接口</td>
</tr>
<tr>
<td>字段</td>
<td>可以定义实例字段</td>
<td>不能定义</td>
</tr>
<tr>
<td>抽象方法</td>
<td>可以定义抽象方法</td>
<td>均为抽象方法</td>
</tr>
<tr>
<td>非抽象方法</td>
<td>可以包含抽象方法</td>
<td>不能包含</td>
</tr>
</tbody></table>
<ul>
<li>抽象类中可以包含抽象方法和成员变量，但是接口只能含有抽象方法</li>
<li>它们都是本质上定义接口规范。保证所有子类都有相同的接口规范</li>
<li>一个实体类只能继承一个抽象类，但是可以实现多个接口</li>
<li>接口之间的继承使用 extends 关键词</li>
<li>接口在定义变量时，默认修饰 <code>public static final</code>，可以省去不写</li>
<li>接口在定义方法是，默认修饰 <code>public abstract</code>, 可以省去。</li>
</ul>
<h3 id="访问作用域 -private-protected-public"><a href="# 访问作用域 -private-protected-public" class="headerlink" title="访问作用域 (private, protected, public)"></a> 访问作用域(private, protected, public)</h3><hr>
<table>
<thead>
<tr>
<th></th>
<th>本类</th>
<th>同一个包(子类和无关类)</th>
<th>不同包下(子类)</th>
<th>不同包下(无关类)</th>
</tr>
</thead>
<tbody><tr>
<td>private</td>
<td>Y</td>
<td>N</td>
<td>N</td>
<td>N</td>
</tr>
<tr>
<td>default</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
<td>N</td>
</tr>
<tr>
<td>protected</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>public</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
</tbody></table>
<ul>
<li>final<ul>
<li>定义为 final 的类，不能被继承</li>
<li>定义为 final 的方法，不能被子类重写</li>
<li>定义为 final 的成员变量，可阻止其被重写赋值</li>
<li>定义为 final 的局部变量，可阻止其被重写赋值</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>HMM</title>
    <url>/2021/03/25/HMM/</url>
    <content><![CDATA[<h1 id="HMM"><a href="#HMM" class="headerlink" title="HMM"></a>HMM</h1><h4 id="1- 马尔可夫性"><a href="#1- 马尔可夫性" class="headerlink" title="1. 马尔可夫性"></a>1. 马尔可夫性 </h4><p> 如果某一时刻 $t \geq 1$ 的随机变量 $x_t$ 与其一时刻随机变量 $x_{t-1}$ 之间有条件分布 $P({x_t}|{x_{t-1}})$, 如果 $x_t$ 与 $t-1$ 时刻之前的状态都没有关系, 仅与 $x_{t-1}$ 状态有关, 这一性质成为马尔科夫性质。<br>$$P(X_t|X_1, X_2,…,X_t-1) = P(X_t|X_{t-1})$$</p>
<h4 id="2- 马尔科夫过程 -or- 马尔科夫链"><a href="#2- 马尔科夫过程 -or- 马尔科夫链" class="headerlink" title="2. 马尔科夫过程 or 马尔科夫链"></a>2. 马尔科夫过程 or 马尔科夫链 </h4><p> 具有马尔科夫性质的序列被成为马尔科夫链条。<br>$$X = (X_1, X_2, …, X_t)$$</p>
<h4 id="3- 马尔科夫链中状态的计算"><a href="#3- 马尔科夫链中状态的计算" class="headerlink" title="3. 马尔科夫链中状态的计算"></a>3. 马尔科夫链中状态的计算 </h4><p> 马尔科夫过程中的 <strong> 状态 $t$</strong> 的状态分布概率的计算，它可以由前一时刻 $t-1$ 的状态分布和状态转移矩阵算出来。<br>$$\pi(t) = P\pi(t-1) = P(P\pi(t-2)) = P^2\pi(t-2)$$<br>即 $$\pi(t) = P^t\pi(0)$$</p>
<span id="more"></span>

<h4 id="4- 隐马尔科夫模型"><a href="#4- 隐马尔科夫模型" class="headerlink" title="4. 隐马尔科夫模型"></a>4. 隐马尔科夫模型</h4><h5 id="4-1- 假设"><a href="#4-1- 假设" class="headerlink" title="4.1 假设"></a>4.1 假设</h5><ul>
<li>观测独立假设: <strong>观测 </strong> 只依赖于该时刻的 <strong> 马尔科夫链的状态</strong>, 与其他观测无关。</li>
<li>马尔科夫性质: 当前状态只与前一状态有关。</li>
</ul>
<h5 id="4-2- 组成"><a href="#4-2- 组成" class="headerlink" title="4.2 组成"></a>4.2 组成</h5><ul>
<li>状态转移矩阵: $A=[a_{ij}]<em>{N \times N}$, $a</em>{ij} = P(y_t=s_j|y_{t-1}=s_i)$。表示 $t-1$ 时刻处于状态 $s_i$ 的时候，在 $t$ 时刻处于 $s_j$ 的概率。</li>
<li>观测概率矩阵: $B=[b_{ij}]<em>{N \times M}$, $b</em>{ij} = P(x_t=o_j|y_t=s_i)$。表示在 $t$ 时刻处于状态 $s_i$, 生成观测值 $o_j$ 的概率。</li>
<li>初始状态概率: $\pi=(\pi_1, \pi_2, …, \pi_N)$, $\pi_i=P(y_1=s_i)$。表示初始状态为 $s_i$ 的概率。</li>
</ul>
<h5 id="4-3- 联合概率分布"><a href="#4-3- 联合概率分布" class="headerlink" title="4.3 联合概率分布"></a>4.3 联合概率分布</h5><p>$P(o_1,s_1,…,o_t,s_t) = P(s_1)P(o_1|s_1)\prod_{i=2}^{t}P(s_i|s_{i-1})P(o_i|s_i)$</p>
<h5 id="4-4- 定义"><a href="#4-4- 定义" class="headerlink" title="4.4 定义"></a>4.4 定义 </h5><p> 通过状态集合 $Q$, 观测集合 $V$, 观测概率矩阵 $B$, 状态转移矩阵 $A$, 初始状态概率向量 $\pi$, 确定一个隐马尔科夫模型，即为:<br>$$\lambda = (A, B, \pi)$$</p>
<h5 id="4-5- 三个基本问题"><a href="#4-5- 三个基本问题" class="headerlink" title="4.5 三个基本问题"></a>4.5 三个基本问题</h5><ul>
<li>识别问题(概率计算算法, 也成为前向算法): 给定模型 $\lambda = (A, B, \pi)$ -&gt; 计算模型与观测序列的匹配程度 $P(O|\lambda)$<ul>
<li>前向算法定义: 输入($\lambda, O$), 输出序列概率 $P(O|\lambda)$</li>
</ul>
</li>
<li>学习问题 (鲍勃 - 韦尔奇算法): 给定观测序列 $O(o_1, o_2, …, o_n)$, 如何训练一个模型 $\lambda = (A, B, \pi)$, 能够使 $P(O|\lambda)$ 最大。</li>
<li>预测算法(维特比算法, 动态规划算法): 给定 $\lambda = (A, B, \pi)$ 和观测序列 $O(o_1, o_2, …, o_n)$, 如果找到此观测序列最匹配的状态序列 $S = (s_1, s_2, …, s_n)$。 由观测样本得到隐状态。</li>
</ul>
<table>
<thead>
<tr>
<th>问题</th>
<th>解决方法</th>
<th>本质</th>
</tr>
</thead>
<tbody><tr>
<td>识别问题</td>
<td>前向算法(Forward Algorithm)</td>
<td>概率的递推计算</td>
</tr>
<tr>
<td>学习问题</td>
<td>Baum-Welch Algorithm</td>
<td>极大似然估计</td>
</tr>
<tr>
<td>解码问题</td>
<td>Viterbi Algorithm</td>
<td>动态规划求最优路径</td>
</tr>
</tbody></table>
<h5 id="4-6- 局限性"><a href="#4-6- 局限性" class="headerlink" title="4.6 局限性"></a>4.6 局限性</h5><ul>
<li>状态值存在 <strong> 长距离的依赖</strong></li>
<li>观测值有非独立的 <strong> 交叉特征</strong></li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>算法, 概率图</tag>
      </tags>
  </entry>
</search>
